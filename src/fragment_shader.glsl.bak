#version 330 core
uniform vec2 resolution;
uniform float time;
in vec2 uv;
out vec4 fragColor;

// MJK123 - 12/09/2025
// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported
// Inspired by: "Mondrian Motion" by matthewscherf â€” https://www.shadertoy.com/view/WfyyWG

const float period = 60.0 / 110.0 * 2.0;

uint seed = 5u;

#define iResolution vec3(resolution, 1.0)
#define iTime time
#define R resolution
#define ASPECT (resolution.x / resolution.y)

#define T iTime / period
#define fT fract(iTime / period)
#define iT floor(iTime / period)

const float PI  = 3.141592653589793;
const float TAU = 6.283185307179586;

vec2 cellId;

bool useSphere;
bool useTexture;
bool useColor;
bool usePixelation;
bool useDithering;
bool useBlack;
bool useCameraMotion;

// Utility
mat2 rot(float a) {
    float s = sin(a), c = cos(a);
    return mat2(c, s, -s, c);
}

float sdSphere(vec3 p, float r) { return length(p) - r; }

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));
}

float InterleavedGradientNoise(vec2 uv) {
    const vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);
    return fract(m.z * fract(dot(uv, m.xy)));
}

// RNG
uint gSeed;

uint hash(uint x) {
    x += x << 10u;
    x ^= x >>  6u;
    x += x <<  3u;
    x ^= x >> 11u;
    x += x << 15u;
    return x;
}

uint hash(uvec2 v) { return hash(v.x ^ hash(v.y)); }
uint hash(uvec3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }
uint hash(uvec4 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w)); }

void initSeed(float x) { gSeed = hash(floatBitsToUint(x) + seed); }
void initSeed(vec2 v)  { gSeed = hash(floatBitsToUint(v) + seed); }
void initSeed(vec3 v)  { gSeed = hash(floatBitsToUint(v) + seed); }
void initSeed(vec4 v)  { gSeed = hash(floatBitsToUint(v) + seed); }

// Convert hashed uint to float in [0,1)
float floatConstruct(uint m) {
    const uint M = 0x007FFFFFu;
    const uint O = 0x3F800000u;
    return uintBitsToFloat((m & M) | O) - 1.0;
}

float random() {
    gSeed = hash(gSeed);
    return floatConstruct(gSeed);
}

vec2 random2() { return vec2(random(), random()); }
vec3 random3() { return vec3(random(), random(), random()); }


// Raymarching
float map(vec3 p) {
    float d = 1e5;
    d = min(d, useSphere ? sdSphere(p, 3.) : sdBox(p, vec3(2)));
    return d;
}

float depth(vec3 ro, vec3 rd) {
    float t = 0.0;

    for (int i = 0; i < 512; i++) {
        float d = map(ro + rd * t);

        if (d < 0.001) return t;
        if (t > 100.0) break;

        t += d;
    }
    return -1.0;
}

vec3 normal(vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    float c = map(p);
    return normalize(vec3(
        map(p + e.xyy) - c,
                          map(p + e.yxy) - c,
                          map(p + e.yyx) - c
    ));
}

float environment(vec3 rd) {
    vec3 lightDir = normalize(vec3(10, 8, 10));
    return mix(0.1, 0.9, smoothstep(-1.0, 1.0, dot(rd, lightDir)));
}

float shade(vec3 ro, vec3 rd) {
    float t = depth(ro, rd);
    if (t < 0.0) return environment(rd);

    vec3 p = ro + rd * t;
    vec3 n = normal(p);

    float albedo = 0.8;
    if (useTexture) {
        vec3 q = p;
        for (int i = 1; i < 8; i++)
            q += cos(q.zxy * float(i) + random() * iTime) / (float(i) * 0.5);

        albedo = smoothstep(-4.0, 3.0, dot(cos(q), vec3(1.0)));
    }

    return albedo * environment(n);
}


vec4 applySubd(vec2 uv, float splits, float stopChance) {
    cellId = vec2(0);

    // cell = (x, y, w, h)
    vec4 cell = vec4(0, 0, 1, 1);

    for (float i = 0.0; i < splits; i++) {
        initSeed(vec3(cellId, iT));

        float r = mix(0.7, 0.3, random() + (random() - .5) * fT * .1);

        vec2 pos = cell.xy;
        vec2 size = cell.zw;

        if (random() > 0.5) {
            // vertical split
            float split = pos.x + size.x * r;
            if (uv.x > split) {
                cell.x += size.x * r;
                cell.z *= 1.0 - r;
                cellId.x += exp2(i);
            } else {
                cell.z *= r;
            }
        } else {
            // horizontal split
            float split = pos.y + size.y * r;
            if (uv.y > split) {
                cell.y += size.y * r;
                cell.w *= 1.0 - r;
                cellId.y += exp2(i);
            } else {
                cell.w *= r;
            }
        }

        if (random() < stopChance) break;
    }

    return cell;
}

void main() {
    vec2 I = gl_FragCoord.xy;
    vec2 uv = I / R;

    // find the subdivided cell this pixel belongs to
    initSeed(iT);
    vec4 cell = applySubd(uv, 10.0, 0.5);
    initSeed(vec3(cellId, iT));

    useSphere = random() < 0.5;
    useTexture = random() < 0.8;
    useColor = random() < 0.05;
    usePixelation = random() < 0.1;
    useDithering = random() < 0.5;
    useBlack = random() < 0.1;
    useCameraMotion = random() < 0.3;

    // local aspect corrected NDC inside cell
    vec2 ndc = (uv - cell.xy) / cell.zw * 2.0 - 1.0;
    ndc *= vec2(ASPECT, cell.w / cell.z);

    if (usePixelation) {
        float res = floor(random() * 20. + 5.);
        ndc = floor(ndc * res) / res;
    }

    // camera setup
    vec3 ro = vec3(0, 0, 20);
    vec3 rd = normalize(vec3(ndc, -(random() * 10.0 + 2.0)));

    vec2 u = random2();
    if (useCameraMotion) {
        float v = random();
        if (v < 0.5) {
            u += (random2() - .5) * T * .3;
            ro.xy += (random2() - .5) * fT * 3.;
        } else if (v < 0.75) {
            u += (random2() - .5) * T * .3;
        } else {
            ro.xy += (random2() - .5) * fT * 3.;
        }
    }
    ro.yz *= rot(u.x * PI);
    rd.yz *= rot(u.x * PI);
    ro.xz *= rot(u.y * TAU);
    rd.xz *= rot(u.y * TAU);

    // shading
    float L = shade(ro, rd);
    vec3 col = vec3(L);

    // stylistic variations
    if (useDithering)
        col *= float(L + InterleavedGradientNoise(I + iTime * 0.01) > 1.1);
    if (useBlack)
        col = vec3(0.0);
    if (useColor) {
        initSeed(iT);
        col = cos(L * random3() * 4. + random() * 100.0) * 0.5 + 0.5;
    }

    // grain
    initSeed(I);
    col += random() * 0.04;
    col *= random() * .2 + .9;

    // tone mapping & gamma
    col *= 28.;
    col = (col / (col + 1.0));
    col = pow(col, vec3(3.2));

    // DARKEN: Make colors much darker for terminal text contrast
    col *= 0.15;  // Reduce brightness significantly

    // draw faint cell outline
    vec2 uvA = uv; uvA.x *= ASPECT;
    vec2 cA  = cell.xy; cA.x *= ASPECT;
    vec2 sA  = cell.zw; sA.x *= ASPECT;
    float dx = min(uvA.x - cA.x, (cA.x + sA.x) - uvA.x);
    float dy = min(uvA.y - cA.y, (cA.y + sA.y) - uvA.y);
    col *= smoothstep(0.0, .003, min(dx, dy));

    fragColor = vec4(col, 1.0);
}
